# Lógica

Estamos tratando con ordenadores. La computación se basa en bits. Los bits
solo pueden tener dos valores: 0 o 1. Verdad o mentira. Este principio se
utiliza para tomar decisiones como, por ejemplo, decidir si un número es mayor
que otro. Ya nos preocuparemos de hacer una reedición de este libro cuando
la computación cuántica introduzca nuevos paradigmas y sea asequible
mortales como nosotros. Pero, vamos a centrarnos...

El tipo asociado a la verdad o mentira, se llama *booleano* en honor a
George Boole y su famosa (y odiada por muchos) "álgebra de Boole".

En muchos lenguajes, podemos utilizar distintos tipos de datos para
representar booleanos, En C y C++ podemos utilizar los enteros 0 y 1 como
booleanos, aunque el propio C++ ya implemente estos tipos de forma nativa.
En Python, cualquier cosa que pueda parecer un booleano lo es, como un entero
o un conjunto. En Go eso no es así, siendo obligatorio el uso de
variables de tipo booleano.

## Operaciones lógicas

Las operaciones lógicas de las que disponemos en Golang son las ya clásicas
de otros lenguajes de programación. Al aplicar estas operaciones, obtendremos
otra salida booleana.

Así pues, el operando negación, ``!``, nos devolverá el valor contrario al
que tengamos. De forma que ``!true`` tiene como valor ``false`` y ``!true``
devolverá ``true``. Para utilizarlo, solo necesitas situarlo delante de lo
que quieres negar. Para utilizarlo, solo se necesita un valor y,
por tanto, es un operador unario. 

El operador ``&&`` corresponde con el operador lógico "and". Si algunos de los
dos elementos que forman parte de la operación tiene como valor ``false``,
el resultado de la operación es ``false``. Para que nos entendamos:

```go
gore> true && true
true
gore> true && false
false
gore> false && true
false
gore> false && false
false
```

El último operador del que disponemos es ``||``, que corresponde al "or"
lógico. Con que uno de los dos operados sea verdadero, el
resultado también lo es:

```go
gore> true && true
true
gore> true && false
true
gore> false && true
true
gore> false && false
false
```

Como ya se ha mencionado arriba, si intentas aplicar los operadores
lógicos a elementos cuyo tipo no sea booleano, obtendremos un error:

```go
gore> 1&&1
# command-line-arguments
/tmp/315015652/gore_session.go:16: invalid operation: 1 && 1 (operator && not defined on untyped number)
error: exit status 2
exit status 2
gore> int(1)&&int(1)
# command-line-arguments
/tmp/315015652/gore_session.go:16: invalid operation: int(1) && int(1) (operator && not defined on int)
error: exit status 2
exit status 2
gore> "falso"||"verdad"
# command-line-arguments
/tmp/315015652/gore_session.go:16: invalid operation: "falso" || "verdad" (operator || not defined on string)
error: exit status 2
exit status 2
```

Esto puede sernos bastante engorroso si venimos de, por ejemplo, Python.
Pero también es una forma de ayudar al programador: solo se va a aplicar
operaciones lógicas a aquellos elementos a los que haya que aplicárselo.

> Ejercicio: se dice que una fórmula es "satisfacible" si es verdadera al 
menos para una combinación de valores. Con una fórmula de 3 variables,
¿cuantas combinaciones posibles de valores hay? Diseña una fórmula y pruébala
sistemáticamente hasta que encuentres si es satisfacible o no. Altérala y
conviértela en no-satisfacible, probándola también sistemáticamente.

Estos operadores necesitan dos operandos y, por tanto, se llaman binarios.
En la mayoría de lenguajes de programación, o al menos en los más conocidos,
se escriben de la misma forma.


Hay otras operaciones como ``→``, que corresponde con la implicación.
Es decir, para ``A → B``, si A, entonces B. Si A es cierto, entonces el
resultado de ``A → B`` es B. Pero si es falso, el resultado estaría
indeterminado, por lo que este operador es, en general, ternario,
expresando dos posibles resultados dependiendo si el antecedente es
cierto o falso. En Python lo expresaríamos como:

```python
"Cierto" if True else "Falso"
"Cierto"
```

En Go no disponemos de operaciones ternarias en una línea,
pero podemos obtener el mismo resultado con el siguiente código:

```go
c := b
if a > b {
    c = a
}
```

## Otras operaciones que devuelven valores lógicos

Algunas operaciones, de las que ya vienen predefinidas en el lenguaje,
también nos devuelven booleanos. El ejemplo más claro, la comparación
utilizando los operandos "<" (menor que), ">" (mayor que), "<=" (menor o 
igual que) o ">=" (mayor o igual que):
 
```go
gore> 1 < 2
true
gore> -22 > -555
true
gore> -2 >= -53.3
true
gore> "arbol" < "brazo"
true
gore> "a" < 21.2
# command-line-arguments
/tmp/315015652/gore_session.go:16: cannot convert "a" to type float64
/tmp/315015652/gore_session.go:16: invalid operation: "a" < 21.2 (mismatched types string and float64)
error: exit status 2
exit status 2
```

El orden de los números es claro, mientras que las cadenas siguen el orden
de la tabla Unicode. Es por ello que si comparamos, por ejemplo, con
una ``ñ``, empiezan a pasar cosas que pueden parecer "raras":

```go
gore> "ñ" < "z"
false
```

Pero, como ya se ha dicho, el orden en el caso de las cadenas de texto viene
determinado por la tabla Unicode.

De nuevo, solo podremos utilizar elementos del mismo tipo con estas
operaciones.

También disponemos de los operandos "==" (igualdad) o "!=" (desigualdad).
Estos operandos se utilizan de igual forma en casi todos los lenguajes,aunque
algunos incluyen también el operando ""==="", como JavaScript, que
diferencia entre [igualdad abstracta e igualdad estricta
y](https://developer.mozilla.org/es/docs/Web/JavaScript/Equality_comparisons_and_sameness).
¿Por qué utilizar dos símbolos de igual en vez de uno? El operando "=" se
guarda para la asignación de valores a variables, eso sí, una vez que han
sido declaradas. Si no las declarado, tienes dos opciones:
``var i int = 1`` o ``i:=1``. La segunda no estará disponible si no estamos
dentro de una función.
